# 编程语言

国内编程语言的课大多又臭又长，翻来覆去就讲语法。好一些的会带上编译过程、执行过程的解释——但都太冗长。  
要想做到**不被语言拖累**，三天上手新语言的水平，我们需要在学语言之前了解编程语言的大概结构：  

- 代码
- parser 语法分析器
- runtime 运行时环境

在文本框中输入代码，parser 负责将**文本代码**翻译为语法树 AST，最后运行时环境（runtime、进程）负责执行 AST。  
![ast](ast.png)  
> 所以，当我们说编译器报错、运行时报错，你至少得知道是**哪个环节**出了问题。  

我们重点关心语法语义层面，只会少量碰到下面的 parser 和 runtime。  

## 开始写代码
程序的定义是**为执行特定任务，经过数据输入，计算后，输出结果**的过程。  
你写的代码，算程序；广义说，法院的流程，也算程序。

所有语言都能找到输出用的方法（函数）。大部分叫`print`，也有叫`out`，甚至有`consloe.log`。

## 条件分支 if

`if` 很简单，写好条件，分两块就行。每个语言都差不多，不需要记忆。  
```js
if (contition) {}
else {}
```
稍微提一下三目，简化了if，用于只返回值的判断分支：
```js
? condition : value1 : value2 // 如果条件为真，返回value1，否则返回value2
message = (score > 60) ? '你及格' : '不及格';
```

## 循环 for 和迭代器

`for` 一般分几种，除了 c 语言带来的三段式习惯，还有配合迭代器的用法。
```js
// 三段式
for(i = 0; i < n; i++) {}

// 迭代器
for(one in something) {}
for(one of something) {}
for one : something {}
```
这些写法太多了，但大致分别如下特点：  
- 三段式：初始化、条件、迭代，循环往复。  
- 迭代器：从 something 中取出一个 one，循环往复。  

三段式太简单了，我们看下for迭代器的用法。

### 迭代器是什么？  

在算法课，我们叫它**数据结构**；在语言的文档里，我们叫**容器类**、**集合类**。层次不同，叫法不同。  
你会经常用到这些容器类，比方：
```js
myArray = [1, 2, 3]; // 数组
myMap = {'Math': 98, 'English': 54}; // 映射
```

稍微解释下：  
> array 数组（有些也叫 list 列表）。一般表现为下标对应元素`数组[下标]`  
> ```js
> a = [1, 'two', 3.14]
> b = a[2] // 3.14
> ```
> map 映射。一般表现为键对应值`键:值`。 
> ```js
> a = {'Math': 98, 'English': 54}
> b = a['Math'] // 98
> ``` 
这些**用不同方式组织起散的数据**的东西叫容器，之所以他们不散，是因为他们都被某种东西连接起来了。  
链接它们的就是**迭代器（iterator）**。  
对于某容器a，你往往能通过`a.begin()`拿到它的首个迭代器，访问它的元素内容和相关信息。然后通过`a.next()`拿到它的下一个元素，直到末尾。  
这个过程叫**迭代（iteration）**。
```js
a = [1, 'two'];
it = a.begin(); print(it.value()); 
// 1
it = it.next(); print(it.value()); 
// 'two'
```
像数组迭的代器顺序，有实际意义，和数组顺序有关。对于许多无序容器，则不必多考虑迭代器顺序意义——**它只是纯粹给你串起来，方便你用 for 遍历的**。  

### 迭代器 for 遍历

这是好文明，得多用。既好看，又易懂，还能吃上语言的各种优化buff。  
比如我们把自己的成绩改及格：  
```js
myMap = {'Math': 98, 'English': 54};
for(let score of myMap) {
    if(score.value < 60)
      score.value = 60
}
```

## 函数 function 
和数学课教的一样。我们要的是这样一个东西：给他喂进去，它能吐出来。  
`sin(x) = y`  
我们叫`sin`为**函数名**，就像`cos`和`tan`一样。它们都能根据输入的东西，吐出相应的答案。  
我们把`x`叫**参数**，表明它就是要喂进去的占位符。  
我们把`y`叫**返回值**，表明它就是我们期待函数吐出来的答案。  

道理都明白了，`sin`的内容是什么？如果不看内容，那我们只会认为`sin`和`cos`只有名字上的区别。这是`sin`的内容：  
```js
// 计算前 10 项泰勒级数
function sin(x) {
    let result = 0, term = x, n = 1;
    for (let i = 0; i < 10; i++) {
        result += term;
        n += 2;
        term *= -x * x / (n * (n - 1));
    }
    return result;
}
```
我们叫这些过程代码叫**函数实现**。  

还有这种写法的：
```c
// add.h
float sin(float x);
// add.c
float sin(float x) {
  ...
}
```
`float sin(float x)`是**函数定义**，描述了`sin`是接受一个`x`（**float**）参数，返回一个**float**值。  
`{...}`这些代码是**函数实现**，规定了具体代码执行的流程。  

因此，函数的**实现和定义可以分开的**。你怎么方便怎么来。  

### 匿名函数 lambda
函数的签名可以和实现分开，在某些情境下非常灵活好用。  
比如，在js中，箭头函数和function作用一样：
```js
const add = (x, y) => { return x + y; }
function add(x, y) { return x + y; }
```
我们来看一个`lambda`的例子：
```js
say = {
  'greeting': (name)=>{ print('hello '+ name) },
  'damn': ()=>{ print('fuck!') },
  'mygod': ()=>{ print('oh my god!') },
}

say['greeting']('张三'); // hello 张三
say['damn'](); // fuck!
```
**有些函数不必返回值——毕竟我们只想要函数执行，不要值**  
我们在一个`map`中挂上许多函数，通过字符串去访问。每个`key键`对应一个`value值`，在这里我们给挂上了函数。  
`say['greeting']`返回了一个匿名函数，你在使用括号`()`调用它，使它执行起来（并在其中填上参数）。  

> 你可能会问，语言还能这么玩？——是的，不管玩的多花，一切都是为了你方便。  
> 你可能会问，这哪里需要匿名函数了？我把这些函数写在全局，起个名字，在`map`中挂函数名不也行吗？——是的，但你的灵活性将大打折扣，你的函数被名字绑死了。  

也有把函数作为参数传入的情况，比如：
```js
const someFunction = (x, y, func) => {
  print(`${x}为男姓名，${y}为女姓名`)
  func(x,y);
}

bob = '鲍勃张'
jenny = '珍妮王'
someFunction(bob, jenny, (x,y) => {
  print(`今天，我们的${x}先生，和${y}女士，喜结连理！`)
  print(`让我们祝福这对新人，白头偕老，永结同心！`)
  print(`恭喜${x}先生和${y}女士，获得原神月卡的奖励！`)
});
```
在`someFunction`中，我们将一个愚蠢的结婚函数塞了进去。由于只想用一次，且实在羞耻，所以我们选择了匿名函数——一般函数会留下耻辱，且不灵活。  

因此，**大部分语言都有 lambda 用法**。用好就行。  
