# Git and Hub

也许最初人们分享项目代码，是靠软盘磁带，后来靠传文件。如果你不想电脑里的压缩包满天飞，每小改一下就传给同事一个压缩包，那么乘早使用**Git**和**GitHub**比较好。  

Git 和 GitHub 的关系，就像：
- 单机游戏之于对战平台
- 本地文件之于云盘
- 快递站之于物流系统

> 我们一般认为，现代人都有网络，都能用上如**GitHub**这类的远程仓库。因此暂不讨论单机玩**Git**的情况

下面是当你加入一个团队后，他们的**Repo**（仓库，装项目代码的地方）可能出现的情况：
![conflict](./conflict.png)

## Git
Git 是一个开源的分布式版本控制系统，用于**保存代码历史**，方便**多人协作**的工具。  

大量时间内基本只会用到几个命令，以下是概念介绍：  
- **conflict** 冲突：两个人同时改了一段代码，Git 不知道用谁的，这叫“冲突”。可以通过商量或用工具解决。
- **branch** 分支：相当于复制一条**单独的开发路线**，你可以在自己的路线上随意修改，不影响主线。
- **merge** 合并：把你的分支改动合并到主项目，就像**把两条路重新连在一起**。
- **clone** 克隆：把别人的项目**拷贝**到自己电脑上。
- **pull** 拉：从远程项目获取最新的代码更新，就像**下载最新版本**。
- **push** 推：把你修改过的代码**上传**到远程项目，别人也能看到。
- **commit** 提交：保存代码修改，类似于**按保存键**，并给每次修改加一个**文字说明**。

想要创建一个**Git**仓库，也就是**Repo**，可以用命令：
```shell
git init {your_path}
```

> 在 commit 时不给文字说明，是不让提交的。如果你被卡 commit 了，记得看一眼 comment（评论）里有没有写文字说明。

因此，聪明的你发现了：如果只是自己用 git，当作备份保存的管理工具，其实只会用到`clone`、`commit`、`push`、`pull`功能。

**说一千道一万，为什么不去自己开个 GitHub 账号，把上面十来行东西试试呢？你这辈子总得试一次才能会吧。一次会，次次就会。**

### GitIgnore
有些时候，你不想把某些文件或文件夹提交到 Git 仓库，比如：
- 临时文件：这些非正式文件很可能写的稀烂，或是机器生成的废料
- 编译生成的可执行文件：又丑又大
- 数据库文件：巨大好吧
- 敏感信息：给人看你的服务器账号密码吗？

因此你可以在项目根目录下创建一个 `.gitignore` 文件，列出这些文件或文件夹，Git 就会自动忽略它们。  
**.gitignore** 异常简单的规则:  
```yml
# 忽略所有.a 文件
*.a
# 但不忽略 lib.a，即便它在 .gitignore 文件中
!lib.a
# 忽略所有 build/ 目录
build/
# 忽略 doc/notes.txt，即便它在 .gitignore 文件中
doc/notes.txt
```
值得注意的是，你得在项目初始化时就写好 gitignore。
在项目中途添加 `.gitignore` 文件时，Git 会按照这个新添加的规则开始忽略指定的文件，但已经被 Git 追踪的文件不会自动被忽略。这是因为 `.gitignore` 只对**未被追踪的文件**生效。

1. **已被追踪的文件**：如果这些文件已经在之前被 Git 追踪，即使你在 `.gitignore` 中添加了它们，Git 仍然会继续追踪它们。换句话说，之前提交的文件不会自动消失，需要手动停止追踪。
2. **未被追踪的文件**：从 `.gitignore` 添加后，未被 Git 追踪的文件会根据规则被忽略，Git 不会再提示它们的状态变化。

- 如果希望停止追踪某个文件，可以使用命令：
  ```bash
  git rm --cached <file>
  ```
  这会让 Git 停止追踪该文件，但文件本身仍然存在于项目目录中。  
  **或者干脆把仓库注销了，重新带上 gitignore 初始化仓库。**

## GitHub